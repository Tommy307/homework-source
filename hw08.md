##1.2  
#1.  
1)
输入 a(十进制)；  

输入数组 s   //用来储存转化后的十六进制数的每一位   
输入 i=0   //记录每个余数在s中的对应位置  


WHILE a/16!=0  

CASE a%16 OF   

condition 1or2or3or4or5or6or7or8or9 ：s[i++]=a%16   
condition 10or11or12or13or14or15 :s[i++]='A'or'B'or'C'or'D'or'E'or'F'  //将余数对应为16进制的表示形式上 
   

ENDCASE
ENDWHILE  

REPEAT  
i=i-1
输出 s[i]   
UNTIL i=0     //将数组s倒着输出即为答案    


2)
#include<stdio.h>
int main(){
	int a ;
    char s[100];                                                                    //用一个数组储存余数
	int i=0;
	scanf("%d",&a);
    if(a<0) {s[0]='-';++i;}
    do{
    switch(a%16){                                                                   //a除以16的余数
	case 1: case 2: case 3: case 4: case 5: case 6: case 7: case 8: case 9:
	s[i++]=(a%16+48);break;                                                         //当余数小于10时直接输出余数（转化为字符）
	case 10: s[i++]='A';break;
	case 11: s[i++]='B';break;
	case 12: s[i++]='C';break;
	case 13: s[i++]='D';break;
	case 14: s[i++]='E';break;
	case 15: s[i++]='F';break;}                                                     //当余数大于等于10时，依次对应字符ABCDEF
	a=a/16;	
    }while(a!=0);
	--i; 
    for(i;i>=0;--i) printf("%c",s[i]);}                                              //倒序输出数组s
}        

3）  

#2.  
1） Top-down design  建立一个新的asm文件 
然后在asm里面第一需要建立的是整个asm的基准，后续不断的插入空的prt文件， 
把需要的prt空文件建完以后，根据顶层的基准创建第一个prt的feature，完善第一个prt以后 
后面的零件可以根据第一个prt，也可以根据顶层的基准来完成feature的创建。以此类推，直到完成整个asm的建立。

2） Work breakdown structure (WBS) 在管理学中WBS就是将一个大的工作分成一个个的层次，每个层次中包含同一优先级的任务，同时这些任务又是由上一层的任务细分而来，这样就能将一个复杂的工作分解成一层层需要先后完成的任务，这样就能更有条理，更完善得完成工作。   

3）简述管理学WBS 与 信息学Top-down设计 的异同：  
其实WBS与Top-down设计的思想是一致的——都是将大的问题分解，再逐一解决细化后的问题，最终达到解决大问题的目的。    
只是两者的实现方法不太一样：  
Top-down设计通过建立上层文件的基准来规范下层文件，这样就使得上层文件的问题等价于下层文件的总和。   
而WBS则更贴近生活，它更像是把要做一件事的所有过程很有条理的列出，同一层次的process则列在同一行，越往下意味着离要做的事的完成就越接近。  
  
#3.   
water_in_switch(open_close)  // open 打开上水开关，close关闭 water_out_switch(open_close)  // open 打开排水开关，close关闭 get_water_volume()  //返回洗衣机内部水的高度motor_run(direction) // 电机转动。left左转，right右转，stop停 time_counter()  // 返回当前时间计数，以秒为单位 halt(returncode) //停机，success 成功 failure 失败
1)正常洗衣：设置上水量+洗涤时间->上水至预设上水量->停止上水->电机开始转动->向左向右交替直到到达预设时间->电机停止转动->排水至水量为0->停机  
2）
START  
water_in_switch(open)  
REPEAT  
get_water_volume()  
UNTIL water_volumw==setting_water_volume   
water_in_switch(close)  
  
REPEAT  
motor_run(left)  
motor_run(right)  
UNTIL time_counter()==setting_time  
halt(returncode)  
  

water_out_switch(open)
REPEAT  
get_water_volume()  
UNTIL water_volumw==0  
water_out_switch(close) 
IF halt(returncode)  RETURN success  
ELSE return failure  
ENDIF  

END   
3)“正常洗衣”注水排水次数会多一次，这样比较浪费水，可以只是延长电机转动时间，而不增加注水次数。  
4）wait_time(setting_time){
	REPEAT  
	time_counter(time)  
	UNTIL time==setting_time  
	RETURN 1  

}   

add_water(volume,time_out){
	water_in_switch(open)  
	WHILE water_volumw!=setting_water_volume  
	get_water_volume()
	IF wait_time(timeout)  water_in_switch(close) water_in_switch(close)  ENDWHILE ENDIF  

	water_volumw==setting_water_volume   
	water_in_switch(close)
	END while  

}
